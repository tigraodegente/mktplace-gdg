#!/usr/bin/env node

import { DatabaseConnector } from './sync/utils/db-connector.mjs'
import OpenAI from 'openai'
import dotenv from 'dotenv'
import path from 'path'
import { fileURLToPath } from 'url'

// Configura√ß√£o
const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)
const rootDir = path.resolve(__dirname, '..')

// Carregar vari√°veis de ambiente
dotenv.config({ path: path.join(rootDir, '.env.local') })

// Configura√ß√µes
const config = {
  model: process.env.OPENAI_MODEL || 'gpt-4-turbo-preview',
  batchSize: 10, // Come√ßar com 10 produtos
  delayBetweenItems: 1000, // 1 segundo entre items
  maxRetries: 3,
  temperatures: {
    seoTitle: 0.7,
    metaDescription: 0.8,
    shortDescription: 0.9,
    tags: 0.3,
    specifications: 0.5
  }
}

// Tracker de custos
const costTracker = {
  totalTokens: 0,
  totalCost: 0,
  productCount: 0,
  startTime: Date.now()
}

// Prompts anti-detec√ß√£o
const MASTER_PROMPT = `
Voc√™ √© um especialista em produtos infantis escrevendo para o e-commerce Gr√£o de Gente.

REGRAS CR√çTICAS PARA CONTE√öDO N√ÉO DETECT√ÅVEL:

1. VARIA√á√ÉO OBRIGAT√ìRIA:
   - Nunca use a mesma estrutura duas vezes
   - Alterne entre frases curtas e longas
   - Varie in√≠cio das frases

2. LINGUAGEM NATURAL:
   - Escreva como um brasileiro real falaria
   - Use express√µes coloquiais ocasionalmente ("super macio", "uma gracinha")
   - Inclua detalhes espec√≠ficos que humanos notariam

3. IMPERFEI√á√ïES HUMANAS:
   - Ocasionalmente use retic√™ncias...
   - Varie uso de exclama√ß√µes
   - √Äs vezes seja mais informal, outras mais profissional

4. EVITE SEMPRE:
   - Palavras muito rebuscadas
   - Estruturas perfeitas demais
   - Repeti√ß√£o de adjetivos
   - Padr√µes √≥bvios de template
`

// Fun√ß√µes de prompt
function getSeoTitlePrompt(product) {
  return `${MASTER_PROMPT}

Crie um t√≠tulo SEO para:
Produto: ${product.name}
Categoria: ${product.category_name || 'Produtos Infantis'}

INSTRU√á√ïES:
- M√°ximo 60 caracteres
- Inclua palavra-chave principal naturalmente
- Varie a estrutura (n√£o sempre "Produto - Categoria | Loja")

EXEMPLOS DE VARIA√á√ÉO:
- "Almofada Nuvem Rosa para Beb√™ | Gr√£o de Gente"
- "Decora√ß√£o Infantil - Almofada Estrela Azul"
- "Kit Ber√ßo Safari Completo 7 Pe√ßas - GDG"

Gere APENAS o t√≠tulo, sem explica√ß√µes.`
}

function getMetaDescriptionPrompt(product) {
  return `${MASTER_PROMPT}

Crie uma meta description para:
Produto: ${product.name}
Pre√ßo: R$ ${product.price}
Categoria: ${product.category_name || 'Produtos Infantis'}

VARIE ENTRE ESTES ESTILOS:
1. Come√ßar com pergunta: "Procurando almofada para beb√™?"
2. Come√ßar com benef√≠cio: "Decore o quarto com nossa..."
3. Come√ßar com o produto: "Almofada Nuvem em algod√£o..."
4. Come√ßar com a√ß√£o: "Compre almofada decorativa..."

Incluir (varie a ordem):
- Descri√ß√£o do produto
- Material ou qualidade
- Benef√≠cio principal
- Men√ß√£o a frete/parcelas (nem sempre)

N√ÉO use sempre 160 chars. Varie entre 145-160.

Gere APENAS a descri√ß√£o, sem explica√ß√µes.`
}

function getShortDescriptionPrompt(product) {
  return `${MASTER_PROMPT}

Crie uma descri√ß√£o curta e persuasiva para:
Produto: ${product.name}
Descri√ß√£o atual: ${product.description}

INSTRU√á√ïES:
- 2-3 frases no m√°ximo
- Destaque benef√≠cios principais
- Use linguagem emotiva mas natural
- Varie o estilo (√†s vezes t√©cnico, √†s vezes emocional)

Gere APENAS a descri√ß√£o curta, sem explica√ß√µes.`
}

function getTagsPrompt(product) {
  return `${MASTER_PROMPT}

Gere tags de busca para:
Produto: ${product.name}
Categoria: ${product.category_name || 'Produtos Infantis'}
Descri√ß√£o: ${product.description}

INSTRU√á√ïES:
- Gere entre 5-10 tags
- Misture tags gerais e espec√≠ficas
- Inclua varia√ß√µes de busca
- Pense como um cliente buscaria

Formato: tag1, tag2, tag3, tag4, tag5

Gere APENAS as tags separadas por v√≠rgula, sem explica√ß√µes.`
}

// Fun√ß√£o de humaniza√ß√£o
function humanizeContent(text, type) {
  // Varia√ß√µes regionais brasileiras
  const variations = {
    "beb√™": ["beb√™", "nen√©m", "baby"],
    "crian√ßa": ["crian√ßa", "pequeno", "pequenino"],
    "bonito": ["bonito", "lindo", "fofo", "uma gra√ßa"],
    "comprar": ["comprar", "adquirir", "garantir o seu"]
  }
  
  // Aplicar varia√ß√µes aleatoriamente
  Object.keys(variations).forEach(key => {
    if (text.includes(key) && Math.random() < 0.3) {
      const options = variations[key]
      const replacement = options[Math.floor(Math.random() * options.length)]
      text = text.replace(key, replacement)
    }
  })
  
  // Ajustar comprimento para meta description
  if (type === 'metaDescription') {
    const targetLength = 145 + Math.floor(Math.random() * 15)
    if (text.length > targetLength) {
      text = text.substring(0, targetLength).trim()
    }
  }
  
  return text
}

// Fun√ß√£o principal de enriquecimento
async function enrichProduct(product, openai, connector) {
  console.log(`\nüîÑ Processando: ${product.name}`)
  
  try {
    const enrichedData = {}
    let productTokens = 0 // Contador de tokens para este produto apenas
    
    // 1. SEO Title
    console.log('  üìù Gerando SEO title...')
    const titleResponse = await openai.chat.completions.create({
      model: config.model,
      messages: [{
        role: 'user',
        content: getSeoTitlePrompt(product)
      }],
      temperature: config.temperatures.seoTitle,
      max_tokens: 100
    })
    
    enrichedData.meta_title = humanizeContent(
      titleResponse.choices[0].message.content.trim(),
      'seoTitle'
    )
    
    // Tracking de custos
    productTokens += titleResponse.usage.total_tokens
    
    // 2. Meta Description
    console.log('  üìù Gerando meta description...')
    const descResponse = await openai.chat.completions.create({
      model: config.model,
      messages: [{
        role: 'user',
        content: getMetaDescriptionPrompt(product)
      }],
      temperature: config.temperatures.metaDescription,
      max_tokens: 200
    })
    
    enrichedData.meta_description = humanizeContent(
      descResponse.choices[0].message.content.trim(),
      'metaDescription'
    )
    
    productTokens += descResponse.usage.total_tokens
    
    // 3. Short Description
    console.log('  üìù Gerando descri√ß√£o curta...')
    const shortDescResponse = await openai.chat.completions.create({
      model: config.model,
      messages: [{
        role: 'user',
        content: getShortDescriptionPrompt(product)
      }],
      temperature: config.temperatures.shortDescription,
      max_tokens: 150
    })
    
    enrichedData.short_description = shortDescResponse.choices[0].message.content.trim()
    productTokens += shortDescResponse.usage.total_tokens
    
    // 4. Tags
    console.log('  üìù Gerando tags...')
    const tagsResponse = await openai.chat.completions.create({
      model: config.model,
      messages: [{
        role: 'user',
        content: getTagsPrompt(product)
      }],
      temperature: config.temperatures.tags,
      max_tokens: 100
    })
    
    const tagsText = tagsResponse.choices[0].message.content.trim()
    enrichedData.tags = tagsText.split(',').map(tag => tag.trim())
    
    productTokens += tagsResponse.usage.total_tokens
    
    // 5. Keywords (baseado nas tags)
    enrichedData.meta_keywords = enrichedData.tags.slice(0, 8).join(', ')
    
    // Calcular custo deste produto
    const inputCost = (productTokens / 1000) * 0.01
    const outputCost = (productTokens / 1000) * 0.03
    const productCost = inputCost + outputCost
    
    // Atualizar totais gerais
    costTracker.totalTokens += productTokens
    costTracker.totalCost += productCost
    
    console.log(`  ‚úÖ Conclu√≠do! Tokens: ${productTokens} | Custo: $${productCost.toFixed(4)}`)
    
    // Salvar no banco
    console.log('  üíæ Salvando no banco...')
    await connector.queryNeon(`
      UPDATE products 
      SET 
        meta_title = $1,
        meta_description = $2,
        short_description = $3,
        tags = $4::jsonb,
        meta_keywords = $5,
        updated_at = NOW()
      WHERE id = $6
    `, [
      enrichedData.meta_title,
      enrichedData.meta_description,
      enrichedData.short_description,
      JSON.stringify(enrichedData.tags),
      enrichedData.meta_keywords,
      product.id
    ])
    
    console.log('  ‚úÖ Salvo com sucesso!')
    
    // Delay entre produtos
    await new Promise(resolve => setTimeout(resolve, config.delayBetweenItems))
    
    return enrichedData
    
  } catch (error) {
    console.error(`  ‚ùå Erro ao processar ${product.name}:`, error.message)
    throw error
  }
}

// Fun√ß√£o principal
async function main() {
  console.log('üöÄ INICIANDO ENRIQUECIMENTO DE PRODUTOS COM IA\n')
  console.log('=' .repeat(60) + '\n')
  
  // Verificar configura√ß√£o
  if (!process.env.OPENAI_API_KEY) {
    console.error('‚ùå OPENAI_API_KEY n√£o configurada!')
    console.error('Execute primeiro: node scripts/setup-and-test-env.mjs')
    process.exit(1)
  }
  
  const connector = new DatabaseConnector({ forceConnection: true })
  const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY })
  
  try {
    await connector.connectNeon()
    
    // Buscar produtos para enriquecer
    console.log('üìä Buscando produtos sem enriquecimento...\n')
    
    const productsResult = await connector.queryNeon(`
      SELECT 
        p.id,
        p.name,
        p.description,
        p.price,
        p.sku,
        c.name as category_name
      FROM products p
      LEFT JOIN categories c ON p.category_id = c.id
      WHERE p.meta_title IS NULL 
         OR p.meta_description IS NULL
         OR p.short_description IS NULL
      ORDER BY p.price DESC
      LIMIT $1
    `, [config.batchSize])
    
    const products = productsResult.rows
    
    if (products.length === 0) {
      console.log('‚úÖ Todos os produtos j√° foram enriquecidos!')
      return
    }
    
    console.log(`üì¶ ${products.length} produtos encontrados para enriquecimento\n`)
    console.log('Produtos a processar:')
    products.forEach((p, i) => {
      console.log(`  ${i + 1}. ${p.name} (${p.sku})`)
    })
    
    // Confirmar antes de prosseguir
    console.log('\n‚ö†Ô∏è  ATEN√á√ÉO:')
    console.log(`Custo estimado: ~$${(products.length * 0.02).toFixed(2)}`)
    console.log('Processando em 3 segundos... (Ctrl+C para cancelar)\n')
    
    await new Promise(resolve => setTimeout(resolve, 3000))
    
    // Processar produtos
    console.log('üîÑ INICIANDO PROCESSAMENTO...\n')
    
    for (let i = 0; i < products.length; i++) {
      const product = products[i]
      console.log(`\n[${i + 1}/${products.length}] Processando...`)
      
      try {
        await enrichProduct(product, openai, connector)
        costTracker.productCount++
      } catch (error) {
        console.error(`‚ùå Erro no produto ${product.name}:`, error.message)
        
        if (error.message.includes('rate limit')) {
          console.log('‚è≥ Rate limit atingido. Aguardando 60 segundos...')
          await new Promise(resolve => setTimeout(resolve, 60000))
          i-- // Tentar novamente
        }
      }
    }
    
    // Resumo final
    const duration = (Date.now() - costTracker.startTime) / 1000
    console.log('\n' + '=' .repeat(60))
    console.log('\nüìä RESUMO DO PROCESSAMENTO:\n')
    console.log(`‚úÖ Produtos processados: ${costTracker.productCount}`)
    console.log(`üí∞ Custo total: $${costTracker.totalCost.toFixed(4)}`)
    console.log(`üìù Tokens usados: ${costTracker.totalTokens.toLocaleString()}`)
    console.log(`‚è±Ô∏è  Tempo total: ${duration.toFixed(0)}s`)
    console.log(`üíµ Custo m√©dio por produto: $${(costTracker.totalCost / costTracker.productCount).toFixed(4)}`)
    
    // Mostrar preview de um produto
    if (costTracker.productCount > 0) {
      console.log('\nüëÄ PREVIEW DE UM PRODUTO ENRIQUECIDO:\n')
      
      const previewResult = await connector.queryNeon(`
        SELECT 
          name,
          meta_title,
          meta_description,
          short_description,
          tags
        FROM products
        WHERE id = $1
      `, [products[0].id])
      
      const preview = previewResult.rows[0]
      console.log(`üì¶ ${preview.name}`)
      console.log(`\nüè∑Ô∏è  SEO Title:\n   "${preview.meta_title}"`)
      console.log(`\nüìù Meta Description:\n   "${preview.meta_description}"`)
      console.log(`\nüí¨ Descri√ß√£o Curta:\n   "${preview.short_description}"`)
      console.log(`\nüè∑Ô∏è  Tags:\n   ${JSON.parse(preview.tags).join(', ')}`)
    }
    
    console.log('\n‚úÖ ENRIQUECIMENTO CONCLU√çDO COM SUCESSO!\n')
    
  } catch (error) {
    console.error('‚ùå Erro geral:', error)
  } finally {
    await connector.disconnect()
  }
}

// Executar
main().catch(console.error) 